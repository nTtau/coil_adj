from pylab import *
from CurrentCollection import CurrentCollection
from Meshtricate import Meshtricate
import MultiProcMagCalc
import logging

##################################################################################
# Function to caculate the Magnetic field generated by a 3-dimensional current sheet
# Other classes could mimic this, but they should implement the following:
# I, update(), B(r), E(V,r)
# Axisymmetric classes should also do r0, psi(r)

mu0=pi*4e-7
logger=logging.getLogger("MagCalc")
logger.addHandler(logging.NullHandler())

class CurrentSheet():
   """
      X: ndarray, shape (3, )
          The location of the nodes in the sheet mesh: [x y z] [units: m]
         - OR -
         a Meshtricate instance
      J: ndarray, shape (3, )
          The sheet current density vectors at each node: [Jx Jy Jz] [units: A/m]

   """
   def __init__(self,X,J,divisible=False):
      if isinstance(X,Meshtricate):
         self.mesh=X
      else:
         self.mesh=Meshtricate(X)
      self.J=J
      self.have_normals=False
      self.divisible=divisible
      
   def calculate_normals(self):
      if not self.have_normals:
         p0=self.X[self.triangles[:,0],:]
         p1=self.X[self.triangles[:,1],:]
         p2=self.X[self.triangles[:,2],:]
         r01=p1-p0
         r12=p2-p1
         self.area_normals = cross(r01,r12)/2.0
         self.areas = sqrt(add.reduce(self.area_normals*self.area_normals,axis=1))
         self.normals = self.area_normals/(self.areas.repeat(3).reshape((-1,3)))
         self.node_areas = zeros((self.X.shape[0],))
         for n in range(self.triangles.shape[0]):
            self.node_areas[self.triangles[n,:]] += self.areas[n]
         self.node_areas /= 3.0
         self.have_normals=True
   
   def A(self,r):
      """
      Returns the magnetic vector potential from the current sheet
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      A: ndarray, shape (m, 3)
          The vector potential at each position specified in r 
          in T*m
      """
      if not isinstance(self,CurrentSheetSlice):
         self.calculate_normals()
      if (self.divisible and (r.shape[0]*self.triangles.shape[0] > 10000) and (MultiProcMagCalc.n_procs >1)):
         logger.debug('current sheet copying')
         stack=CurrentCollection([])
         for n in range(MultiProcMagCalc.n_procs):
            logger.debug('slice')
            stack.append(CurrentSheetSlice(self,slice(n,None,MultiProcMagCalc.n_procs)))
         logger.debug('current sheet calculating')
         return stack.B(r)
      else:
         A=[]
         for pt in range(r.shape[0]):
   #         if ((pt%5000) == 0):
   #            print '{}% complete'.format(pt*100.0/r.shape[0])
            x=r[pt,:]-self.X
            scalar_part=self.node_areas/add.reduce(x*x,axis=1)**0.5
            A.append(add.reduce(self.J*scalar_part.repeat(3).reshape((-1,3))))
      return array(A)*1e-7

   def B(self,r):
      """
      Returns the magnetic field from the current sheet
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      B: ndarray, shape (m, 3)
          a vector for the B field at each position specified in r 
          in T
      """
      if not isinstance(self,CurrentSheetSlice):
         self.calculate_normals()
      if (self.divisible and (r.shape[0]*self.triangles.shape[0] > 10000) and (MultiProcMagCalc.n_procs >1)):
         logger.debug('current sheet copying')
         stack=CurrentCollection([])
         for n in range(MultiProcMagCalc.n_procs):
            logger.debug('slice')
            stack.append(CurrentSheetSlice(self,slice(n,None,MultiProcMagCalc.n_procs)))
         logger.debug('current sheet calculating')
         return stack.B(r)
      else:

         B=[]
         for pt in range(r.shape[0]):
   #         if ((pt%5000) == 0):
   #            print '{}% complete'.format(pt*100.0/r.shape[0])
            x=r[pt,:]-self.X
            scalar_part=self.node_areas/add.reduce(x*x,axis=1)**1.5
            B.append(add.reduce(cross(self.J,x)*scalar_part.repeat(3).reshape((-1,3))))
         return array(B)*1e-7

   def render(self,**kwargs):
      from mayavi import mlab as Mlab
      if 'name' not in kwargs:
         try:
            kwargs['name']=self.name
         except:
            kwargs['name']="current sheet"
      if 'color' not in kwargs:
         try:
            kwargs['color']=self.color
         except:
            kwargs['color']=(1.0,0.6,0.8)
      if 'opacity' not in kwargs:
         try:
            kwargs['opacity']=self.opacity
         except:
            kwargs['opacity']=0.5
      return Mlab.triangular_mesh(self.X[:,0], self.X[:,1], self.X[:,2], self.triangles, **kwargs)
   
   def plot(self,**kwargs):
      self.mesh.plot()

   def ohmslaw_E(self, Hall_B=None):
      E=dot(self.resistivity,self.J)
      if Hall_B is not None:
         E += self.Hall_coeff * cross(self.J, Hall_B)  
      
def field_aligned(B, lamda, seeds, length, cycle=False,direction=0):
   # B is callable with an X vector
   # Calculate J at seeds (lamda is mu0*J/B, J being in A/m
   # For each requested direction:
   #    While any field line is less than length:
   #       For each field line:
   #          If up to length, continue
   #          Integrate from last point to min(macro-step size, length) (macro-step is the distance/sqrt(3) between seeds)
   #          If triangle left and right are well-conditioned:
   #             add the point to the node list 
   #             Store new J (just the J of the previous node on the field line) 
   #          else if too squat: # field lines have diverged
   #             discard triangles
   #             on each side:
   #                Spline a new seed, inserting before this one into seed list.  
   #                Give it accumulated length same as its neighbors (average, plus the triangle altitude)
   #                Take 1/4 current from the far neighbor and 1/2 current from this line (so 1,1,1,1,1 become 1,.75,.75,.75,.75,1)
   #          else too skinny: # field lines have converged
   #             discard triangles
   #             Make a triangle with the previous node on this line, and the most recent from the two neighbors
   #             Give each neighbor half this current
   #             Remove this line from the seed list
   do_forward=(direction == 1)
   do_backward=(direction == -1)
   do_length=length
   if (direction ==0):
      do_forward=True
      do_backward=True
      do_length /=2.0
   X=[seed for seed in seeds] #bust out into a list for easy appending
   triangles=[]
   point_idx=seeds.shape[0]-1
   dL=mean([norm(dx) for dx in diff(seeds,axis=0)])/sqrt(3)

   if do_forward:
      points=[n for n in range(seeds.shape[0])]
      lengths=[0.0 for seed in seeds]
      all_to_length=False
      while not all_to_length:
         all_to_length=True
         for n,point in enumerate(points):
            if (lengths[n] >= do_length):
               continue
            dx=array([0,dL,0])
            lengths[n] += norm(dx)
            new_X=X[point]+dx
            X.append(new_X)
            point_idx += 1
            if ((n>0) or cycle):
               triangles.append([point_idx,points[n],points[n-1]])
            if (n<len(points)-1):
               triangles.append([point_idx,points[n+1],points[n]])
            elif cycle:
               triangles.append([point_idx,points[0],points[n]])
            points[n]=point_idx
            all_to_length=all_to_length and lengths[n] >= do_length
   if do_backward:
      pass
   Xarr=array(X)
   return CurrentSheet(Xarr, array(triangles), B(Xarr)*lamda/mu0)

def test():
   #isodd=lambda n: bool(n & 1)
   r=0.01
   L=1.0
   i=0
   X=[]
   J=[]
   triangles=[]
   n_theta=11
   d_theta=2*pi/n_theta
   dL=d_theta*r*sqrt(3.)*2
   for m,z in enumerate(arange(-0.5*L,0.5*L,dL)):
      i_start=i
      for n in range(n_theta):
         theta=(n+0.5*m)*d_theta
         X.append([r*cos(theta),r*sin(theta),z])
         J.append([0.,0.,1e6/2/pi/r]) # 1 MA total
         if m>0:
            if n>0:
               triangles.append([i,i-n_theta,i-1])
            if (i+1-n_theta == i_start):
               triangles.append([i,i+1-2*n_theta,i-n_theta])
               triangles.append([i,i+1-n_theta,i+1-2*n_theta])
            else:
               triangles.append([i,i+1-n_theta,i-n_theta])
         i+=1
      #if m>0:
      #   triangles.append([i-1,i_start,i+1-n_theta])
   return CurrentSheet(array(X),array(triangles),array(J))

class CurrentSheetSlice(CurrentSheet):
   def __init__(self,sheet,sliced):
      self.X=sheet.X[sliced]
      self.J=sheet.J[sliced]
      self.node_areas=sheet.node_areas[sliced]
      self.divisible=False

if __name__=='__main__':
   MultiProcMagCalc.yes_I_have_wrapped_my_main=True
   logger.setLevel(logging.DEBUG)
   loghandler=logging.StreamHandler(stream=sys.stdout)
   #loghandler=logging.FileHandler(os.path.join(directory,'{}bagmodel.log'.format(prefix)),mode='w')
   loghandler.setLevel(logging.DEBUG)
   logformatter=logging.Formatter('[%(asctime)s %(levelname)s/%(processName)s %(funcName)s] %(message)s')
   loghandler.setFormatter(logformatter)
   logger.addHandler(loghandler)
   testsheet=test()
   from mayavi import mlab as MLab
   n_grid=40
   L_chamber=0.5
   x,y,z=mgrid[-L_chamber/2:L_chamber/2:n_grid*1j,-L_chamber/2:L_chamber/2:n_grid*1j,-L_chamber/2:L_chamber/2:n_grid*1j]
   B=testsheet.B(vstack( (x.flat,y.flat,z.flat) ).transpose())
   Bx,By,Bz=(B[:,0].reshape(x.shape), B[:,1].reshape(y.shape), B[:,2].reshape(z.shape))
   MLab.flow(x,y,z,Bx,By,Bz)
   testsheet.render(representation='wireframe')
   figure()
   hold(True)
   Xax=zeros((n_grid,3))
   Xax[:,0]=x[:,n_grid/2,n_grid/2]
   B=testsheet.B(Xax)
   xax=Xax[:,0]
   plot(xax, B[:,0], label='Bx')
   plot(xax, B[:,1], label='By')
   plot(xax, B[:,2], label='Bz')
   theory=mu0*1e6/2/pi/xax
   theory[where(abs(xax)<0.01)]=0.
   plot(xax,theory,label='theory')
   legend()
   show()
