from pylab import *
from scipy.special import ellipe, ellipk
from scipy.optimize._basinhopping import RandomDisplacement
try:
   from scipy.special import ellipkm1
   have_ellipkm1=True
except:
   have_ellipkm1=False

##################################################################################
# Function to caculate the Magnetic field generated by a circular current filament
# Other classes could mimic this, but they should implement the following:
# I, update(), B(r), E(V,r)
# Axisymmetric classes should also do r0, psi(r)

class MagCoil:
   """
      MagCoil(r0,normal,R=1.0,I=1.0,r_minor=None,wire=None):
      
      r0: ndarray (3, ): The location of the center of the loop in units of d: [x y z] 
      normal: ndarray (3, ) The normal vector to the plane of the loop at the center, 
      R: float: The radius of the current loop 
      I: float: The current in the loop, oriented by the right-hand-rule about the normal vector.  
      r_minor: float: The minor radius (for rendering only, not for field calculations)
      wire: dict: a selection from AWG or AWG_square (overrides r_minor)
   """
   def __init__(self,r0,normal,R=1.0,I=1.0,r_minor=None,wire=None):
      self.r0=r0
      self.normal=normal
      self.R=R
      self.I=I
      self.mu=pi*4e-7
      self.r_minor=r_minor
      self.wire=wire
      self.update()
      self.mesh=self.render # for compatibility

   def move(self,displacement):
      self.r0 += displacement
      
   def set_I(self, I):
      self.I=I
   
   def discretize_current(self):
      n_points=100
      IdLmag=self.I * 2*pi*self.R /n_points
      theta=linspace(0.0,2*pi,n_points,endpoint=False)
      theta += random_sample()*theta[1]
      
      rrot_T=vstack((self.R*cos(theta),self.R*sin(theta),zeros_like(theta))) # point coordinates in the shifted frame (coil centered on 0,0,0 and pointed 0,0,1); transposed
      rtrans=self.rotmtx.transpose()*matrix(rrot_T) # rotate to global coordinates 
      for i in range(3): rtrans[i,:] += self.r0[i] # translate to global coordinates
      points=array(rtrans).transpose()
      
      IdL=matrix([-sin(theta)*IdLmag, cos(theta)*IdLmag, zeros_like(theta)])
      return array((self.rotmtx.transpose()*IdL).transpose()),points
      
   def update(self):
      """ Calculates rotmtx, which transforms coordinates from the lab frame
          to axes with coil field in positive Z direction
      """
      self.normal=self.normal/norm(self.normal)
      self.rotmtx=matrix(zeros((3,3)))
      v1=random(3)
      while (norm(cross(v1,self.normal)) < 0.1):
         v1=random(3)
      v2=cross(self.normal,v1)
      v2=v2/norm(v2)
      v3=cross(self.normal,v2)
      self.rotmtx[0,:]=v2
      self.rotmtx[1,:]=v3
      self.rotmtx[2,:]=self.normal
      self.B0=self.mu*self.I/2/self.R

   def A(self,r):
      """
      Returns the magnetic vector potential from an arbitrary current loop
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      A: ndarray, shape (m, 3)
          The vector potential at each position specified in r 
          in T*m
      """
      self.update()
      rtrans=matrix(r).transpose()
      for i in range(3): rtrans[i,:] -= self.r0[i]

      rrot=array(self.rotmtx*rtrans).transpose()
  
      # express the coordinates in polar form
      x = rrot[:, 0] # radial
      y = rrot[:, 1] # also radial
      z = rrot[:, 2] # axial
      rho = sqrt(x**2 + y**2)
      theta = arctan2(y,x)
      alpha=rho/self.R
      beta=z/self.R
      #gamma=z/rho
      Q=(1+alpha)**2 + beta**2
      m=4*alpha/Q

      E = ellipe(m)
      if have_ellipkm1:
         K = ellipkm1(1-m)
      else:
         K = ellipk(m)
      Aphi = 2*self.R*self.B0*( (2-m)*K - 2*E ) / (m*pi*sqrt(Q))
      Aphi[isnan(Aphi)] = 0
      Aphi[isinf(Aphi)] = 0
      Az=zeros_like(Aphi)
   
      A = matrix([-1*sin(theta)*Aphi, cos(theta)*Aphi, Az])
   
      # Rotate the field back in the lab's frame
      return array((self.rotmtx.transpose()*A).transpose())

   def B(self,r):
      """
      Returns the magnetic field from an arbitrary current loop
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      B: ndarray, shape (m, 3)
          a vector for the B field at each position specified in r 
          in T
      """
      self.update()
      rtrans=matrix(r).transpose()
      for i in range(3): rtrans[i,:] -= self.r0[i]

      rrot=array(self.rotmtx*rtrans).transpose()
  
      # express the coordinates in polar form
      x = rrot[:, 0] # radial
      y = rrot[:, 1] # also radial
      z = rrot[:, 2] # axial
      rho = sqrt(x**2 + y**2)
      theta = arctan2(y,x)
      alpha=rho/self.R
      axis=where(alpha < 1e-9)
      rho[axis]=5.678e6 # bogus value, is huge
      beta=z/self.R
      gamma=z/rho # should be ~ inf on axis, bogus value makes it small
      Q=(1+alpha)**2 + beta**2 # ~ alpha**2 for the bogus value
      m=4*alpha/Q #~4/alpha for the bogus value
      denom=Q-4*alpha 

      E = ellipe(m)
      if have_ellipkm1:
         K = ellipkm1(1-m)
      else:
         K = ellipk(m)

      a2_plus_b2=alpha**2+beta**2
      B0overPiSqrtQ=self.B0/pi/sqrt(Q)
      B0GammaoverPiSqrtQ=B0overPiSqrtQ * gamma
      geomfactor=( E*(1-a2_plus_b2)/denom + K )
    #  print( "K : ", K) 
   #   print( "Denom : ", denom) 
    #  print("Geom factor 1 ",geomfactor)
      Bz   = B0overPiSqrtQ * geomfactor
      geomfactor=(E*(1+a2_plus_b2)/denom - K)
    #  print( "K : ", K) 
   #   print( "Denom : ", denom) 
    #  print("Geom factor 2 ",geomfactor)
      Brho = B0GammaoverPiSqrtQ *  geomfactor
      Brho[isnan(Brho)] = 0
      Brho[isinf(Brho)] = 0
      Brho[axis]=0
      Bz[isnan(Bz)]     = 0
      Bz[isinf(Bz)]     = 0
      Bz[axis]=self.mu*self.I*self.R**2 / (2*(self.R**2+z[axis]**2)**1.5)
   
      B = matrix([cos(theta)*Brho, sin(theta)*Brho, Bz])
   
      # Rotate the field back in the lab's frame
      return array((self.rotmtx.transpose()*B).transpose())

   def flux(self,A,res=100,coax=False):
      """
      Returns the magnetic flux through this coil calculated from a given vector potential
      Arguments
      ---------
         A: callable, takes an argument of ndarray (m, 3) and returns the vector potential at those locations
            Position argument is in m, returning vector potential in Wb/m
         res: (optional) number of steps to integrate around the coil; default=100
         coax: (optional) Assume a coaxial/axisymmetric system [A() is axisymmetric and purely azimuthal]; default=False
      
      Returns
      -------
      flux: float
         the flux through the coil, in Wb
      """
      self.update()
      if coax:
         R1=matrix([self.R,0.0,0]).transpose()
      else:
         theta=linspace(0,2*pi,res)
         x1=self.R*cos(theta)
         y1=self.R*sin(theta)
         z1=zeros_like(x1)
         R1=matrix([x1,y1,z1])
      R2=array((self.rotmtx.transpose()*R1)).transpose()+self.r0
      AA=A(R2)
      if coax:
         return sqrt(sum(AA**2))*2*pi*self.R
      else:
         dL=diff(R2,axis=0)
         AA=AA[:-1,:]+diff(AA,axis=0)
         return sum(AA*dL)
      
      
   def psi(self,r):
      """
      Returns the magnetic flux from an arbitrary current loop
      
      Arguments
      ----------
           r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      psi: ndarray, shape (m, 3)
          a vector for the flux at each position specified in r 
          in Wb
      """

      self.update()
      rtrans=matrix(r).transpose()
      for i in range(3): rtrans[i,:] -= self.r0[i]

      rrot=array(self.rotmtx*rtrans).transpose()
   
      # express the coordinates in polar form
      x = rrot[:, 0]
      y = rrot[:, 1]
      z = rrot[:, 2]
      rho = sqrt(x**2 + y**2)

      alpha=rho/self.R
      beta=z/self.R
      #gamma=z/rho
      Q=(1+alpha)**2 + beta**2
      #d2=(x+self.R)**2 + z**2
      m=(4*alpha/Q)
   
      E = ellipe(m)
      K = ellipk(m)
      psi=self.B0*0.5*K/pi*sqrt(Q)*(2*(K-E)/K-m)
      psi[isnan(psi)] = 0

   
      # Rotate the field back in the lab's frame
      return array(psi)

   def _meshpoints(self, n_points=50, **keywords):
      self.update()

      try:
         render_type=self.wire['render_type']
      except:
         render_type='round'
         rminor=self.r_minor
         if rminor is None:
            rminor=self.R/1000
      angles=linspace(0, 2*pi, n_points)
      if render_type == 'square':
         x=empty((n_points, 5), dtype=float)
         y=empty_like(x)
         z=empty_like(x)
         for i,theta in enumerate(angles):
            for j,(dr,dz) in enumerate(zip([-self.wire['width']/2, -self.wire['width']/2, self.wire['width']/2, self.wire['width']/2, -self.wire['width']/2],
                                           [-self.wire['width']/2, self.wire['width']/2, self.wire['width']/2, -self.wire['width']/2, -self.wire['width']/2])):
               R= self.R + dr
               X=R*cos(theta)
               Y=R*sin(theta)
               Z=dz
               Rvec=matrix([X,Y,Z]).transpose()
               Rvec=self.rotmtx.transpose()*Rvec + matrix(self.r0).transpose()
               x[i,j]=Rvec[0,0]
               y[i,j]=Rvec[1,0]
               z[i,j]=Rvec[2,0]
      else:
         x=empty((n_points, n_points), dtype=float)
         y=empty_like(x)
         z=empty_like(x)
         for i,psi in enumerate(angles):
            for j,theta in enumerate(angles):
               R= self.R + rminor*cos(psi)
               X=R*cos(theta)
               Y=R*sin(theta)
               Z=rminor*sin(psi)
               Rvec=matrix([X,Y,Z]).transpose()
               Rvec=self.rotmtx.transpose()*Rvec + matrix(self.r0).transpose()
               x[i,j]=Rvec[0,0]
               y[i,j]=Rvec[1,0]
               z[i,j]=Rvec[2,0]
      return (x,y,z)
   
   def render(self, n_points=None, **keywords):
      import mayavi.mlab as MLab

      if n_points is None:
         try:
            n_points=self.n_points
         except:
            n_points=50
      (x,y,z)=self._meshpoints(n_points)
      if 'name' not in keywords:
         try:
            keywords['name']=self.name
         except:
            keywords['name']="coil"
      if 'color' not in keywords:
         try:
            keywords['color']=self.color
         except:
            keywords['color']=(0.2,0.2,0.2)
      self.mlab_object=MLab.mesh(x, y, z, **keywords)
      return self.mlab_object
