from pylab import *
from scipy.spatial import Delaunay
from Meshtricate import Meshtricate
from CurrentCollection import CurrentCollection, n_procs
#MLab.options.offscreen=True

##################################################################################
# Function to caculate the Magnetic field generated by a 3-dimensional current density

mu0=pi*4e-7

class _interpolator(): # TODO: this should come from Meshtricate
   def __init__(self,tri):
      self.Delaunay=tri
   def __call__(self,values,locations,default=0.0):
      r=array(locations).reshape((-1,3))
      val_out=default*ones((r.shape[0],)+values.shape[1:],dtype=values.dtype)
      for i,simplex in enumerate(self.Delaunay.find_simplex(r)):
         if simplex >=0: # simplex -1 is returned for points outside the domain
            barycentric=self.Delaunay.transform[simplex,:3, :].dot(r[i,:]-self.Delaunay.transform[simplex,3,:])
            barycentric = hstack((barycentric,1-sum(barycentric)))
            val_out[i,...]=dot(barycentric,values[self.Delaunay.vertices[simplex],...])
      if val_out.size==1: # only one point requested, scalar values
         return val_out[0]
      else:
         if val_out.shape[0]==1: # only one point requested, vector/tensor values
            val_out.shape=val_out.shape[1:]
         if values.ndim == 1: # scalar values, so flatten to num. locations
            val_out=val_out.flatten()
         return val_out
           
class _gradient(): # TODO: move this to Meshtricate
   def __init__(self,tri):
      self.Delaunay=tri
   def __call__(self,values,locations,default=0.0):
      r=array(locations).reshape((-1,3))
      val_out=default*ones((r.shape[0],)+values.shape[1:]+(3,),dtype=values.dtype)
      for i,simplex in enumerate(self.Delaunay.find_simplex(r)):
         if simplex >=0: # simplex -1 is returned for points outside the domain
            barycentric_0 = array(0,0,0,1)
            barycentric_dx=self.Delaunay.transform[simplex,:3, :].dot(array(1,0,0))
            barycentric_dx = hstack((barycentric_dx,1-sum(barycentric_dx)))
            barycentric_dy=self.Delaunay.transform[simplex,:3, :].dot(array(0,1,0))
            barycentric_dy = hstack((barycentric_dy,1-sum(barycentric_dy)))
            barycentric_dz=self.Delaunay.transform[simplex,:3, :].dot(array(0,0,1))
            barycentric_dz = hstack((barycentric_dz,1-sum(barycentric_dz)))
            v0=dot(barycentric_0,values[self.Delaunay.vertices[simplex],...])
            vx=dot(barycentric_dx,values[self.Delaunay.vertices[simplex],...])
            vy=dot(barycentric_dy,values[self.Delaunay.vertices[simplex],...])
            vz=dot(barycentric_dz,values[self.Delaunay.vertices[simplex],...])
            val_out[i,...,0]=vx-v0
            val_out[i,...,1]=vy-v0
            val_out[i,...,2]=vz-v0
      if val_out.size==3: # only one point requested, scalar values
         return val_out[0,:]
      else:
         if val_out.shape[0]==1: # only one point requested, vector/tensor values
            val_out.shape=val_out.shape[1:]+(3,)
         if values.ndim == 1: # scalar values, so flatten to num. locations x3
            val_out=val_out.flatten((-1,3))
         return val_out
           
class _gradient_at_nodes(): # TODO: move this to Meshtricate
   def __init__(self,tri):
      self.Delaunay=tri
   def __call__(self,values):
      r=self.Delaunay.points
      val_out=zeros((r.shape[0],)+values.shape[1:]+(3,),dtype=values.dtype)
      for simplex in range(self.Delaunay.vertices.shape[0]):
         barycentric_0 = array([0,0,0,1])
         barycentric_dx=self.Delaunay.transform[simplex,:3, :].dot(array([1,0,0]))
         barycentric_dx = hstack((barycentric_dx,1-sum(barycentric_dx)))
         barycentric_dy=self.Delaunay.transform[simplex,:3, :].dot(array([0,1,0]))
         barycentric_dy = hstack((barycentric_dy,1-sum(barycentric_dy)))
         barycentric_dz=self.Delaunay.transform[simplex,:3, :].dot(array([0,0,1]))
         barycentric_dz = hstack((barycentric_dz,1-sum(barycentric_dz)))
         v0=dot(barycentric_0,values[self.Delaunay.vertices[simplex],...])
         vx=dot(barycentric_dx,values[self.Delaunay.vertices[simplex],...])
         vy=dot(barycentric_dy,values[self.Delaunay.vertices[simplex],...])
         vz=dot(barycentric_dz,values[self.Delaunay.vertices[simplex],...])
         val_out[self.Delaunay.vertices[simplex],...,0] += (vx-v0)*self.Delaunay.simplex_volumes[simplex]
         val_out[self.Delaunay.vertices[simplex],...,1] += (vy-v0)*self.Delaunay.simplex_volumes[simplex]
         val_out[self.Delaunay.vertices[simplex],...,2] += (vz-v0)*self.Delaunay.simplex_volumes[simplex]
      val_out /= self.Delaunay.volumes.reshape((-1,1))
      if values.ndim == 1: # scalar values, so flatten to num. locations x3
         val_out=val_out.reshape((-1,3))
      return val_out      

class CurrentVolume():
   """
      X: ndarray, shape (n, 3)
          The location of the nodes in the volume grid: [x y z] [units: m]
         - OR -
         a Meshtricate instance
      J: ndarray, shape (n, 3)
          The current density vectors at each node: [Jx Jy Jz] [units: A/m]

   """
   def __init__(self,X,J,divisible=False): # scipy v0.13 adds features, probably want to pass **kwargs thru to Delaunay
      #volumes: ndarray, shape (1, )
      #    Gives the Voronoi polygon volumes for each node element (node volume for regular grids). [units: m**3]
      #TODO: rework based on Meshtricate instances (self.mesh.Delaunay rather than self.Delaunay)
      self.divisible=divisible
      self.J=J
      if isinstance(X, Meshtricate):
         self.mesh=X
         self.X=X.Delaunay.points
         self.Delaunay=X.Delaunay # TODO: deprecated
      else:
         self.X=X
         self.Delaunay=Delaunay(X,qhull_options="QJ")
      self.Delaunay.interpolator=_interpolator(self.Delaunay) #TODO: let the Meshtricate class implement this
      self.Delaunay.volumes=zeros(self.X.shape[0])
      self.Delaunay.simplex_volumes=zeros(self.Delaunay.vertices.shape[0])
      #totvol=0.0
      for i,simplex in enumerate(self.Delaunay.vertices):
         mat=self.X[simplex[1:],:]-self.X[simplex[0],:]
         #The volume of this simplex is 1/6 |mat|, and so each node gets 1/4 of its volume
         self.Delaunay.simplex_volumes[i]=abs(det(mat)/6.0)
         self.Delaunay.volumes[simplex] += self.Delaunay.simplex_volumes[i]/4
         #totvol += abs(det(mat)/6.0)
      self.Delaunay.gradient=_gradient(self.Delaunay)
      self.Delaunay.gradient_at_nodes=_gradient_at_nodes(self.Delaunay)
      
   def A(self,r):
      """
      Returns the magnetic vector potential from the current
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      A: ndarray, shape (m, 3)
          The vector potential at each position specified in r 
          in T*m
      """
      if isinstance(self,CurrentVolumeSlice) or not self.divisible:
         A=[]
         for pt in range(r.shape[0]):
            x=r[pt,:]-self.X
            dist_sq=add.reduce(x*x,axis=1)
            idx,=where(dist_sq == 0)
            dist_sq[idx]=1
            scalar_part=self.Delaunay.volumes/dist_sq**0.5
            scalar_part[idx]=0
            A.append(add.reduce(self.J*scalar_part.repeat(3).reshape((-1,3))))
         return array(A)*1e-7
      else:
         collection=CurrentCollection([])
         n_slices=min(n_procs,self.X.shape[0])
         for n in range(n_slices):
            collection.append(CurrentVolumeSlice(self.X[n::n_procs,:],self.Delaunay.volumes[n::n_procs],self.J[n::n_procs,:]))
         return collection.A(r)

   def B(self,r):
      """
      Returns the magnetic field from the current
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      B: ndarray, shape (m, 3)
          a vector for the B field at each position specified in r 
          in T
      """
      if isinstance(self,CurrentVolumeSlice) or not self.divisible:
         B=[]
         for pt in range(r.shape[0]):
            x=r[pt,:]-self.X
            dist_sq=add.reduce(x*x,axis=1)
            idx,=where(dist_sq == 0)
            dist_sq[idx]=1
            scalar_part=self.Delaunay.volumes/dist_sq**1.5
            scalar_part[idx]=0
            B.append(add.reduce(cross(self.J,x)*scalar_part.repeat(3).reshape((-1,3))))
         return array(B)*1e-7
      else:
         collection=CurrentCollection([])
         n_slices=min(n_procs,self.X.shape[0])
         for n in range(n_slices):
            collection.append(CurrentVolumeSlice(self.X[n::n_procs,:],self.Delaunay.volumes[n::n_procs],self.J[n::n_procs,:]))
         return collection.B(r)

   def j(self,r):
      return self.Delaunay.interpolator(self.J,r)
   
   def replicate(self):
      self.mesh.fields['J']={'value':self.J,'type':'pseudovector'} #not really a pseudovector, but reflects like one in a mesh48
      meshes=self.mesh.replicate()
      result=CurrentCollection([])
      for m in meshes:
         result.append(CurrentVolume(None,m.fields['J'],mesh=m)) # TODO: deal with self.divisible.  Maybe just leave it "None" since we're probably going into a 48pc. collectoion?
         result[-1].J=m.fields['J']['value']
      return result
   
   def render(self, **kwargs):
      import mayavi.mlab as MLab
      if 'name' not in kwargs:
         try:
            kwargs['name']=self.name
         except:
            kwargs['name']="current density"
      MLab.quiver3d(self.X[:,0],self.X[:,1],self.X[:,2],self.J[:,0],self.J[:,1],self.J[:,2], **kwargs)

class dummy():
   pass
      
#   def mesh(self):
#      from mayavi import mlab as Mlab
#      try:
#         name=self.name
#      except:
#         name="current sheet"
#      try:
#         color=self.color
#      except:
#         color=(1.0,0.6,0.8)
#      print 'Shape(X)={}'.format(self.X.shape)
#      return Mlab.triangular_mesh(self.X[:,0], self.X[:,1], self.X[:,2], self.triangles, name=name, color=color)

class CurrentVolumeSlice(CurrentVolume):
   def __init__(self,X,volumes,J):
      self.X=X
      self.Delaunay=dummy()
      self.Delaunay.volumes=volumes
      self.J=J
      
def field_aligned(Xarr, B, lamda=1):
   return CurrentVolume(Xarr, B*lamda/mu0)

