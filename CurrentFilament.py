from pylab import *

##################################################################################
# Function to caculate the Magnetic field generated by a current filament in 3D space
# Other classes could mimic this, but they should implement the following:
# I, update(), B(r), E(V,r)
# Axisymmetric classes should also do r0, psi(r)

mu0=pi*4e-7

class CurrentFilament():
   """
      X: ndarray, shape (3, )
          The location of the nodes in the filament: [x y z] [units: m]
      I: scalar
          The filament current [units: A]

   """
   def __init__(self,X,I):
      self.X=array(X)
      self.I=I

   def length(self):
      dL=sqrt(sum(diff(self.X,axis=0)**2,axis=1))
      #print (self.X)
      #print(dL)
      return(sum(dL))

   def IdX(self):
      dX=diff(self.X,axis=0)
      this_IdX=zeros_like(self.X)
      this_IdX[:-1,:] += self.I*dX/2.0
      this_IdX[1:,:] += self.I*dX/2.0
      return this_IdX

   def A(self,r):
      """
      Returns the magnetic vector potential from the current filament
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      A: ndarray, shape (m, 3)
          The vector potential at each position specified in r 
          in T*m
      """
      A=[]
      dX=diff(self.X,axis=0)
      midX=self.X[1:,:]-dX/2
      #dL=sqrt(sum(dX**2, axis=1))
      for pt in range(r.shape[0]):
         x=r[pt,:]-midX
         scalar_part=add.reduce(x*x,axis=1)**-0.5
         A.append(add.reduce(dX*scalar_part.repeat(3).reshape((-1,3))))
      return self.I*array(A)*1e-7

   def B(self,r):
      """
      Returns the magnetic field from the current filament
      Arguments
      ----------
          r: ndarray, shape (m, 3)
               A position vector where the magnetic field is evaluated: 
               [x1 y1 z1 ; x2 y2 z2 ; ... ] 
               r is in m
       
      Returns
      --------
      B: ndarray, shape (m, 3)
          a vector for the B field at each position specified in r 
          in T
      """
      B=[]
      dX=diff(self.X,axis=0)
      midX=self.X[1:,:]-dX/2
      #dL=sqrt(sum(dX**2, axis=1))
      for pt in range(r.shape[0]):
         x=r[pt,:]-midX
         scalar_part=add.reduce(x*x,axis=1)**-1.5
         B.append(add.reduce(cross(dX,x)*scalar_part.repeat(3).reshape((-1,3))))
      return self.I*array(B)*1e-7

   def render(self, **kwargs):
      from mayavi import mlab as Mlab
      if 'name' not in kwargs: 
         try:
            kwargs['name']=self.name
         except:
            kwargs['name']="current filament"
      if 'color' not in kwargs:
         try:
            kwargs['color']=self.color
         except:
            kwargs['color']=(0.0,0.0,0.0)
      if 'tube_radius' not in kwargs:
         try:
            kwargs['tube_radius']=self.r_minor
         except:
            pass
      return Mlab.plot3d(self.X[:,0], self.X[:,1], self.X[:,2], **kwargs)

def field_aligned(B, I, seed, length, direction=0):
   do_forward=(direction == 1)
   do_backward=(direction == -1)
   do_length=length
   if (direction ==0):
      do_forward=True
      do_backward=True
      do_length /=2.0
   X=[seed] #bust out into a list for easy appending
   X_backward=[seed]
   if do_forward:
      dL=max(abs(seed))/1e5
      if(dL == 0.0):
         dL=1e6*float(finfo(float32).tiny)
      length=0.0
      while (length < do_length):
         # figure out step size
         B0=B(X[-1])
         gradB=0.0
         while (gradB <= 0.0):
            Bx=norm(B(X[-1]+dL/100.0*array([1,0,0]))-B0)
            By=norm(B(X[-1]+dL/100.0*array([0,1,0]))-B0)
            Bz=norm(B(X[-1]+dL/100.0*array([0,0,1]))-B0)
            gradB=norm([Bx,By,Bz])*100/dL
            dL *= 2 # increase the step size until we sample a gradient 
         dL=norm(B0)/gradB*0.001
         #Predictor
         dx=dL*B0/norm(B0)
         B1=B(X[-1]+dx)
         #Corrector
         B2=(B0+B1)/2.0
         dx=dL*B2/norm(B2)
         
         length += dL
         new_X=X[-1]+dx
         X.append(new_X)
   if do_backward:
      dL=max(abs(seed))/1e5
      if(dL == 0.0):
         dL=1e6*float(finfo(float32).tiny)
      length=0.0
      while (length < do_length):
         # figure out step size
         B0=B(X_backward[-1])
         gradB=0.0
         while (gradB <= 0.0):
            Bx=norm(B(X_backward[-1]+dL/100.0*array([1,0,0]))-B0)
            By=norm(B(X_backward[-1]+dL/100.0*array([0,1,0]))-B0)
            Bz=norm(B(X_backward[-1]+dL/100.0*array([0,0,1]))-B0)
            gradB=norm([Bx,By,Bz])*100/dL
            dL *= 2 # increase the step size until we sample a gradient 
         dL=norm(B0)/gradB*0.001
         #Predictor
         dx=dL*B0/norm(B0)
         B1=B(X_backward[-1]-dx) #minus since we're going backward
         #Corrector
         B2=(B0+B1)/2.0
         dx=dL*B2/norm(B2)
         
         length += dL
         new_X=X_backward[-1]-dx #minus since we're going backward
         X_backward.append(new_X)
   Xarr=vstack((array(X),array(X_backward[1:])[::-1]))
   return CurrentFilament(Xarr, I)

def test():
   #isodd=lambda n: bool(n & 1)
   L=10
   z=linspace(-0.5*L,0.5*L,10000)
   y=zeros_like(z)
   x=zeros_like(z)
   return CurrentFilament(vstack((x,y,z)).T,1.0)

if __name__=='__main__':
   tester=test()
   R=array([0.001,0,0]).reshape((1,3))
   print('ideal: [0, {}, 0], calculated:{}'.format(mu0/2/pi/R[0,0],tester.B(R)))
   R=array([0.3,0,0]).reshape((1,3))
   print('ideal: [0, {}, 0], calculated:{}'.format(mu0/2/pi/R[0,0],tester.B(R)))
   
